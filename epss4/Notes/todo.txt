This file describes things that will, should, or could be implemented in the code. They have to do with programming, not economics. 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (0) What this branch does 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
074-minor_improvements: save results so that Matlab can always read (see errors in shell_output.txt). correct calc of cross-sectional variance of consumption and portfolio return (graphs).
    calculate Medians and report them in equilibrium_long? In particular for portfolio return   

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (A) Next steps 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- record and report stats for gross wages (important when def benefits) (in simulations and save_results)

- implement a check on lowest income shock gridpoint whether it is negative - discussion with Christian Zimmermann at Zilibotti's
        but do I actually need that or is it specified in logs?
- implement check if stockmarket also clears
- set_apmax conditions on bequests_to_newborn, which is default .true. even if we do not have survival risk. Should check and correct or impove.
- reading the data from calibration files goes wrong if there is no explanation in 'third column', without error message. Need to change that.  

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (B) To do
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- write t_scrap into simvars, especially the unformatted, because when the old simvars are read to initialize, and the stats are calculated, 
    then it can happen that the 'new' t_scrap (i.e. in the new calib-file) is larger than the 'old' nt. Concretely, run_model:137 'K%name ='K' ; call K%calc_stats(simvars_old)' can fail.
- splines for value function and consumption in Euler equations / household solution? Maybe also to interpolate stocks and bonds?
- use the type tPolicies everywhere instead of redefining xgrid etc (Distribution, fun_excessbonds, save_results_mod, policyfunctions).
    -- started, but is not so easy: the newly defined xgrid etc have less dimensions. 
        Allocating tPolicies with extent 1 in that dimension introduces a lot of cumbersome notation with brackets like (:,:,1,:,:,:) .
        Instead, could have an extended derived type extra with less dimensions - but what happens to all the type-bound procedures?
        See my comment in policyfunctions:interpolate, and the correspondence on CLF
    -- could put the errors only in the 'normal' type and call later from there (and not have them in the smaller types)    
    -- in policyfunctions, remove app_min, instead calc for all ap (using the new type policies), and then address element zc=1 where needed.

- correct eigenvalue calc of stationary distribution (in module markov_station_distr, see also params_mod:CheckParams), check codes/Fortran/Bewley_by_Karibzhanov/source/toolbox   
- maybe remove apmax_factor from the calibration files, and put it as a parameter when creating the apmax for ms. It's not needed later (for GE)
- clean up files: merge rootfinders into one module rootfinder and tools (like linesearch, fdjac); merge the 3 markov*.f90 files and the twostate_exact.f90;
    merge tools like fun_kronprod.f90 and numrec_utils into utils. Clean up all the usage of these, e.g. of markov* in params_mod   

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (C) Further ideas
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- rewrite the calibration_mod, so that it reads in the name of the associated param. This would greatly increase usability, because I only need
    to change the calibration files by adding or removing or changing params. However, also need an identifier for the associated target in the calibration file.
    Even better: put the end params at the beginning of each calibration file, and next to it the target. read them in like normal parameters, but then write the param name
    into a temporary character array, increase n_end_params by one, and read the target into a character array. finally, allocate two character arrays of size n_end_params, copy params and targets into them.
    No need for n_end_params in calibration file.
- give grids in run_model_mod SAVE, so that agg grid can be updated once in the beginning and not later?
- make params_mod readable by Matlab and read it in
- have an option to skip the mean shock equilibrium (use opt_initial_ms_guess for this)
- move value into policies
- make interpolateXgrid a (type-bound?) function
- make nx, n_eta, nz ... private in params_mod? nx should be relatively easy! 
    I think better: put into policies! But that might interfere when I define the type as a tuple of scalars and then use arrays of the type... but that's far into the future 
- have an aggregate grid for each z, coz mu and k change a lot with z (k coz depreciation, mu coz probabilities of high return tomorrow).
    This should help a lot to avoid the problem that either kappa is not found in hh solution, or mu hits bounds in simulation.
    But then remove if(rfp < rp(1)) in policyfunctions:calc_vars_tomorrow
- in household_solution, the loops for mu and k do not conform anymore to the ordering of the states, because I interchanged the outer loops so that
    OpenMP can work on the capital grid. So now the outermost loop does not work on the rightmost state anymore (which still is mu). Should change that, but I 
    think it's difficult, because need to correct indeces everywhere in the program.
- Instead of having tPolicies with allocatable components, make tPolicies a tuple (of scalars) and then define arrays of tPolicies. Should work much better, also for 
adding, interpolating, calling routines, having less dimensions. But have to think it through, not clear how interpolation and other type-bound procedures could be called.
- arithmetic operations on tPolicies? Maybe not needed.
- maybe allow for fractions in calibration files (e.g. 1/3). For this, in ReadCalib, put '(3(a,:))' (: being a stop rule), then scan for \ and make the 
    division, if \ is found. Hoever, this doesnt allow 1/theta directly. Also, prob need to remove the / in the separator lines.
- Move the Build* folders (i.e. the build configurations) to one folder bin. However, with managed make this doesn't seem allowed, see ->Properties->Fortran Build: Build directory. 
If I try to change this, I should first try it on a new copy (not even a branch, but a new clone or new repository), just to make sure...
- Make Distribution Phi a derived type, so that it can carry the grid over which it is defined. See my comments in krusell_smith_mod.f90. 
    Could delete xgrid_ms in run_model_mod and make local in SolveMeanshock. Could make interpolate_xgrid:InterpolateXgrid_Phi a type-bound procedure
- replace Intel's system(string) subroutine, which is a non-portable extension, with the F2008 execute_command_line(string),
    which is already supported by Gfortran. It is not yet supported by the Intel Fortran compiler. Don't forget to remove the use ifport
    See CLF post: http://comp.lang.fortran.narkive.com/Iua1GCiT/system-vs-execute-command-line   
- errors_mod: detailed_euler_errs not used at the moment!
- errors_mod: either initialize err%cons and err%asset with xp in first dimension, or save to file with explicit format. At the moment the
    files written to disk are difficult to read. Also, setting detailed_euler_errs=.true. should write to file, not to stdout, because it's too much for stdout.
- move "if (errs%not_converged) call errs%write2file(fvals, output_path)" 
  from meanshock_wrapper and main:internal_subroutine_krusellsmith())
  to save_results_mod. For this need to put fvals into err, make allocatable.
  This helps to make the procedures pure, and also more logical: all saving to file is done in save_results_mod
  See whether can clean up krusell_smith:get_krusellsmith and meanshock_equilib:ms_equilib_get; they are a bit messy because of
  the errs%not_converged (This should not be a prob once errs is passed as an object in the rootfinder... alternatively could overload the assignment operator) 
- in fun_eulerasset I do Taylor approx IFF xp<x(1,j+1). Should also do for upper bound? And also for consumption-Euler?!
- create derived types for  loms (has types coeffs and grids), prices (wages etc)?
- use simulate_economy also in mean_shock_mod? Not so easy, because want to save mean shock results in the first 'period' of simvars. 
    Maybe this becomes easier if the derived types are defined on scalar tuples.
- change depreciation to have its own dimension? affects probabilities, and ups_grid, ups_sigma
- maybe mod_demographics.f90?
- put the formatted write into the types. see save_results_mod.f90
- Call aggregate_grids_class just grids? And use aggregate_grids_class also for apgrid??
- lifecycles_mod with calculation of lifecycles, consistent both with mean shock and simulations
- for lifecycles, make 'sub'type with avg and std_dev, and record for all; maybe also avg_cond std_dev_cond (conditional on survival). 
    Also make a write statement similar to the aggregate stats.  put pop_frac in lifecycles
- in simulations, use a tLifecycle 'lc_t' to record in t, and define an operator (+) to add that to the lifecylce 
- Make type params and have a method that distributes the params to the objects that need them, e.g. policyfunctions. No more need for all the use statements
    Then I can have an allocatable type params in main, see how many runs we have (depends on experiment / number of calibs), then allocate and have a params
    for each, which I then pass by argument to start_solution, which has a scalar type params as input.
- Type results, which contains all the results we are interested in, can print them in formatted and unformatted way. This is helpful for e.g. the no AR economy to read in directly the values.
- Merge coefficients_class into laws_of_motion. Maybe class laws_of_motion which has a component coefficients_class. 
 - Copyleft: http://www.gnu.org/copyleft/gpl-howto.html

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (D) Done! (started only in Nov. 2012) reverse chronological order
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- remove cmin from calibration files. Instead in params_mod, have cmin= min(1e-10, tol_asset_eul), and put a warning if tol_asset_eul<1e-12.

- put maxstep for Krusell_smith in calibration files. In particular, noIR needs maxstep 0.02

- let broyden algorithm report the convergence criterion, not (or better in addition to) the abs max.

- put sharpe ratio (and equity premium) as the last target in each target file, bc that's the one I turn off most. Need adjust calibration_mod.
    Put second-least-need target second-to-last. Actually, this might be too complicated, because I should rewrite the whole thing anyway, see below.

- calibration routine should save params in each step (so I can see progress or why no progress, and also use the params.txt together with
    the saved unformatted loms if the calibration should be aborted)

- This didn't work: add a kappa_max, which helps to speed up the solution and also for the cases where ap very close to zero

- one procedure to forecast both mup and kp, it takes both coeffs as input and gridpoints k and mu
    this makes it much easier to test for optimal lom, and have different loms for each. Try [kp, mup] =Forecast()
       At the moment very hackish to distinguish forecasting mu' from k'. 
- in save_results_mod, write regressors (k, k**2, etc) on top of each separately (for k' and mu')

- add option in calibration files: maxstep for the calibration routine: it is .2 for IES=0.5 and .02 for IES=1.5

- add option in calibration file to set lower and upper bound of aggregate grids directly?

- set nj to expected life expectancy if no survival rates

- option to perform whole welfare decomposition and save results

- target r with del_mean, warn for std(w)?

- correct survival probs

- target std(w) (didnt help much)

- bequests to the young

-I get many error rfp in equilibrium_short.txt. I calculated upper bound for mu from the inverse of f_riskfree_rate, i.e. mu_max = E(r|z1) - rp(1) -1e-4. 
    Then rfp =rp(1) + 1e-4. Note the expectation given the bad state today, because that state has a lower expected return.
    Did this in version 032-mu_grid, but discontinued, because mu_max so small that many errors in simulations.

- Given that I have more points now, I now keep aggregate grids fixed.

- made construction and update of aggregate grids (in particular capital) better: exponential grid, and more points 
    (for the latter, had to interchange the loops in household_solution, so that OpenMP works on capital grid).

- replace calibrate_model by n_end_params = 0

- add calibration routine

- parallelize simulation

- make simvars class and coeffs class. see unformatted_io and laws_of_motion

- put reading and writing of unformatted output together. Better: make different objects and put all reading and writing there.
In the course of this, check that all components of a type are read and written. 
For example, simvars should read and write output unformatted also, see  subroutine SaveUnformatted_ksvars in unformatted_io.f90 and laws_of_motion.f90:ReadUnformatted 

- rewrite unformatted IO to use form='unformatted', access='stream' for better portability
    (first only change the unformatted write, then run all calibrations, then change the unformatted read)

- subfolder src_classes    

- make aggregate grids with type-bound procedures. And put makegrid in there?

- update agg_grid in krusell_smith so that doesn't hit borders

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 (E) Done! (started in June 2013) chronological order
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- put tolerance in simulation into the calibration files : instead of this, I set tol_simulation_marketclearing = tol_asset_eul*10_dp

071-return_cons: since the new idea of averaging the policies in the risk dimension did not work, I will keep the old calculation, where households re-optimize,
                and then make an adjustment with aggregate consumption. For this, mean aggregate consumption needs to be returned to main.f90. Then omega (the ratio
                of mean aggregate consumption) is computed and multiplied with CEV. 

072-meanshock_rev: revisit mean shock equilibrium. Specifically, check whether results change if I use stat_dist_z instead of we, wz. 
                    Maybe use policy%mean like in insurance_effect_mod 

073-read_previous: As default action, read unformatted input from the subfolder with the same name as this calibration. If that subfolder does not exist, read as before from
                    model_input/last_results. Can be turned off with logical, so that subfolder is not searched. Should use shell for that.
                    Also, want a subfolder for each calibration with tau002 and tau000, and previous, where both these subfolders are copied in.
                    Issue warning if a subfolder is not found.
                